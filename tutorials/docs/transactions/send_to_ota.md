---
Description: Tutorial on how to create transaction sending to OTAReceiver.
---
# Before Going Further
Please read through the tutorials on [key submission](../accounts/submit_key.md) and [UTXO cache](../accounts/utxo_cache.md) for proper
balance and UTXO retrieval. Skip these parts if you're familiar with these notions.

# Transferring to One-time Addresses
In this tutorial, we'll walk through what an OTAReceiver means and how to send assets to an OTAReceiver.

## OTAReceiver
Usually, when we want to send some PRV or pTokens to someone, we must have his/her payment address. This is
the [canonical way](../transactions/raw_tx.md) for transferring assets inside the Incognito network. However, a payment
address leaks some past history (e.g, v1 transactions, old shielding requests, old trading transactions, etc,.) of the 
receiver that he/she doesn't want the sender to know. Therefore, we need a mechanism to address this problem. This is why 
[`OTAReceiver`'s](../../../coin/receiver.go) are invented. An OTAReceiver allows us to receive a coin without the need of
a payment address. The main difference is that: suppose Alice wants to send some PRV to Bob
- Using Bob's payment address: Alice generates a coin, encrypts it and sends necessary data to Bob for him to recover the coin.
- Using an OTAReceiver generated by Bob: Bob generates a coin with some preset data (e.g, PublicKey, Concealing Key, etc,.)
and tells Alice to make this coin valid (i.e, send PRV to this coin). This is somehow the same as a "payment request".

An OTAReceiver looks like the following:
```go
// OTAReceiver holds the data necessary to receive a coin with privacy.
// It is somewhat equivalent in usage with PaymentAddress.
type OTAReceiver struct {
	// PublicKey is the one-time public key of the receiving coin.
	PublicKey crypto.Point
	
	// TxRandom is for the receiver to recover the receiving information.
	TxRandom  TxRandom

	// SharedSecrets are for the sender to mask the amount as well as the asset type of the sending coins.
	// SharedSecrets = []crypto.Point{sharedOTAPoint, sharedConcealPoint}:
	//	- sharedOTAPoint: used for generating the one-time address and concealing the assetID.
	//	- sharedConcealPoint: used for concealing the amount.
	// For non-privacy transactions, this field can be omitted.
	SharedSecrets []crypto.Point `json:"SharedSecrets,omitempty"`
}
```

Don't worry about this complicated structure because you can easily generate an OTAReceiver from your payment address using
the method `FromAddress()`:
```go
receiverAddr := "12sm5BLDevJsUbevkJd7eaU9zAiuNixEeUsNnYddnsqEYTrcFMfE7aSS2J6mK3GeHbdT7LMm4VcRETaJCRzzU8xKKa1Tn2t9XcGiqWSDpG7jewQkDeRDY3czMHVEgwWGfUWMvkd2pWr1QpMw1i4s"
w, err := wallet.Base58CheckDeserialize(receiverAddr)
if err != nil {
    log.Fatal(err)
}
otaReceiver := new(coin.OTAReceiver)
err = otaReceiver.FromAddress(w.KeySet.PaymentAddress)
if err != nil {
    log.Fatal(err)
}
```
`FromAddress()` takes an optional parameter indicating the shardID of the sender. While this is not necessary at the moment,
this will be enforced in the future at the chain-level. If not set, the shardID of the payment address will also be the shardID
of the sending shard (i.e, sending in the same shard).


Next, we can serialize an OTAReceiver into a string sequence using the `String()` method:
```go
otaReceiverStr := otaReceiver.String(true) // set `isConcealable = true` to enable receiving within confidential transactions
fmt.Printf("otaReceiver: %v\n", otaReceiverStr)
```
The `String()` method takes an optional boolean parameter indicating if we want to OTAReceiver to be able to used in a 
private transaction. By default, the serialized string only supports receiving asset within non-private transactions (e.g, trading response, shielding response)
where the receiving amount and receiving assetID are transparent. Pass a `true` to the `String()` method will allow receiving
asset in a confidential way. Concretely, here is the description of the `String()` method:
```go
// String marshals the OTAReceiver, then encodes it with base58.
// By default, an OTAReceiver will only support receiving assets in a non-private transaction. Set `isConcealable = true`
// to enable receiving assets in a private transaction.
func (receiver OTAReceiver) String(isConcealable ...bool) string {
	return base58.Base58Check{}.NewEncode(receiver.Bytes(isConcealable...), common.ZeroByte)
}
```
The serialized OTAReceiver can then be used to receive assets as usual. See the following example.

## Example
[main.go](../../code/transactions/send_to_ota/main.go)

```go
package main

import (
	"fmt"
	"github.com/incognitochain/go-incognito-sdk-v2/coin"
	"github.com/incognitochain/go-incognito-sdk-v2/incclient"
	"github.com/incognitochain/go-incognito-sdk-v2/wallet"
	"log"
)

func main() {
	client, err := incclient.NewTestNetClientWithCache()
	if err != nil {
		log.Fatal(err)
	}

	privateKey := "112t8rneWAhErTC8YUFTnfcKHvB1x6uAVdehy1S8GP2psgqDxK3RHouUcd69fz88oAL9XuMyQ8mBY5FmmGJdcyrpwXjWBXRpoWwgJXjsxi4j"
	receiverAddr := "12sm5BLDevJsUbevkJd7eaU9zAiuNixEeUsNnYddnsqEYTrcFMfE7aSS2J6mK3GeHbdT7LMm4VcRETaJCRzzU8xKKa1Tn2t9XcGiqWSDpG7jewQkDeRDY3czMHVEgwWGfUWMvkd2pWr1QpMw1i4s"
	w, err := wallet.Base58CheckDeserialize(receiverAddr)
	if err != nil {
		log.Fatal(err)
	}
	otaReceiver := new(coin.OTAReceiver)
	err = otaReceiver.FromAddress(w.KeySet.PaymentAddress)
	if err != nil {
		log.Fatal(err)
	}
	otaReceiverStr := otaReceiver.String(true) // set `isConcealable = true` to enable receiving within confidential transactions
	fmt.Printf("otaReceiver: %v\n", otaReceiverStr)

	txParam := incclient.NewTxParam(privateKey, []string{otaReceiverStr}, []uint64{100000}, 0, nil, nil, nil)
	encodedTx, txHash, err := client.CreateRawTransaction(txParam, -1)
	if err != nil {
		log.Fatal(err)
	}

	err = client.SendRawTx(encodedTx)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf("Create and send tx successfully, txHash: %v\n", txHash)
}
```
---
Return to [the table of contents](../../../README.md).
